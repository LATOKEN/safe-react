{"version":3,"sources":["logic/tokens/api/fetchSafeCollectibles.ts","logic/collectibles/sources/Gnosis.ts","logic/collectibles/sources/index.ts","logic/collectibles/store/actions/fetchCollectibles.ts","logic/currentSession/store/actions/addViewedSafe.ts","logic/safe/store/actions/fetchSafe.ts","logic/tokens/store/actions/fetchSafeTokens.ts","logic/safe/api/fetchTokenCurrenciesBalances.ts","routes/safe/components/FetchError.tsx","routes/safe/components/SafeLoadError.tsx","logic/safe/store/actions/fetchLatestMasterContractVersion.ts","routes/safe/container/index.tsx","logic/safe/hooks/useLoadSafe.tsx","logic/currencyValues/store/actions/updateAvailableCurrencies.ts","logic/safe/hooks/useSafeScheduledUpdates.tsx"],"names":["fetchSafeCollectibles","safeAddress","a","getCollectibles","_getChainId","checksumAddress","Gnosis","_getAssetsFromTokens","tokens","map","address","decimals","undefined","logoUri","name","tokenName","symbol","tokenSymbol","type","TokenType","ERC721","_fetch","collectibles","erc721Assets","erc721Tokens","logError","Errors","_604","message","this","nftTokens","extractTokens","nftAssets","extractAssets","assets","extractedAssets","forEach","asset","extractNFTAsset","token","assetAddress","color","description","image","imageUri","NFTIcon","tokenId","id","mainAssetAddress","numberOfTokens","filter","sameAddress","length","slug","SOURCES","gnosis","fetchCollectibles","dispatch","setNftTokensLoaded","source","COLLECTIBLES_SOURCE","toLowerCase","addNftAssets","addNftTokens","console","log","addViewedSafe","updateViewedSafes","buildSafe","safeInfo","loadedViaUrl","local","getLocalSafe","getSafeInfo","catch","err","remote","extractRemoteSafeInfo","remoteSafeInfo","localSafeInfo","owners","buildSafeOwners","fetchSafe","isInitialLoad","dispatchPromises","state","store","getState","chainId","currentChainId","currentSafeWithNames","collectiblesTag","txQueuedTag","txHistoryTag","shouldUpdateCollectibles","shouldUpdateTxHistory","shouldUpdateTxQueued","push","fetchSafeTokens","fetchTransactions","Promise","all","updateSafe","loaded","extractDataFromResult","acc","balance","fiatBalance","tokenInfo","balances","tokenAddress","tokenBalance","humanReadableValue","Number","ZERO_ADDRESS","ethBalance","makeToken","currency","currentSafe","selectedCurrency","currentCurrencySelector","fetchTokenCurrenciesBalances","tokenCurrenciesBalances","_601","items","reduce","totalFiatBalance","BigNumber","fiatTotal","toFixed","addTokens","excludeSpamTokens","trustedTokens","getBalances","exclude_spam","trusted","StyledLink","styled","Link","ErrorContainer","div","FetchError","text","buttonText","redirectRoute","onClick","src","alt","size","to","variant","SafeLoadError","useDispatch","useSelector","WELCOME_ROUTE","removeViewedSafe","fetchLatestMasterContractVersion","getCurrentMasterContractLastVersion","latestVersion","setLatestMasterContractVersion","BALANCES_TAB_BTN_TEST_ID","SETTINGS_TAB_BTN_TEST_ID","APPS_TAB_BTN_TEST_ID","TRANSACTIONS_TAB_BTN_TEST_ID","ADDRESS_BOOK_TAB_BTN_TEST_ID","SAFE_VIEW_NAME_HEADING_TEST_ID","TRANSACTIONS_TAB_NEW_BTN_TEST_ID","Home","lazy","Apps","Settings","Balances","TxList","AddressBookTable","Container","featuresEnabled","currentSafeFeaturesEnabled","useSafeAddress","isSafeLoaded","useState","hasLoadFailed","setHasLoadFailed","useEffect","load","getFiatCurrencies","availableCurrencies","setAvailableCurrencies","_607","resolve","useLoadSafe","pollCount","setPollCount","timer","setTimeout","prev","SAFE_POLLING_INTERVAL","clearTimeout","useSafeScheduledUpdates","failedTimeout","isOpen","title","body","footer","onClose","modal","setModal","exact","path","SAFE_ROUTES","DASHBOARD","render","wrapInSuspense","LEGACY_COLLECTIBLES","generateSafeRoute","ASSETS_BALANCES_COLLECTIBLES","extractPrefixedSafeAddress","ASSETS_BALANCES","TRANSACTIONS","TRANSACTIONS_HISTORY","TRANSACTIONS_QUEUE","TRANSACTIONS_SINGULAR","ADDRESS_BOOK","APPS","history","includes","FEATURES","SAFE_APPS","SETTINGS"],"mappings":"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","file":"static/js/58.1d7e352f.chunk.js","sourcesContent":["import { getCollectibles, SafeCollectibleResponse } from '@gnosis.pm/safe-react-gateway-sdk'\nimport { _getChainId } from 'src/config'\nimport { checksumAddress } from 'src/utils/checksumAddress'\n\nexport const fetchSafeCollectibles = async (safeAddress: string): Promise<SafeCollectibleResponse[]> => {\n  return getCollectibles(_getChainId(), checksumAddress(safeAddress))\n}\n","import { SafeCollectibleResponse, TokenType } from '@gnosis.pm/safe-react-gateway-sdk'\n\nimport { Collectibles, NFTAsset, NFTAssets, NFTTokens } from 'src/logic/collectibles/sources/collectibles.d'\nimport { sameAddress } from 'src/logic/wallets/ethAddresses'\nimport NFTIcon from 'src/routes/safe/components/Balances/assets/nft_icon.png'\nimport { fetchSafeCollectibles } from 'src/logic/tokens/api/fetchSafeCollectibles'\nimport { Errors, logError } from 'src/logic/exceptions/CodedException'\n\ntype TokenResult = {\n  address: string\n  decimals?: number\n  logoUri: string\n  name: string\n  symbol: string\n  type: TokenType\n}\n\ntype FetchResult = {\n  erc721Assets: TokenResult[]\n  erc721Tokens: SafeCollectibleResponse[]\n}\nclass Gnosis {\n  _getAssetsFromTokens = (tokens: SafeCollectibleResponse[]): TokenResult[] => {\n    const assets: TokenResult[] = tokens.map(({ address, logoUri, tokenName, tokenSymbol }) => ({\n      address,\n      decimals: undefined,\n      logoUri,\n      name: tokenName,\n      symbol: tokenSymbol,\n      type: TokenType.ERC721,\n    }))\n\n    return assets\n  }\n\n  _fetch = async (safeAddress: string): Promise<FetchResult> => {\n    const collectibles: FetchResult = {\n      erc721Assets: [],\n      erc721Tokens: [],\n    }\n\n    try {\n      const tokens = await fetchSafeCollectibles(safeAddress)\n      collectibles.erc721Assets = this._getAssetsFromTokens(tokens)\n      collectibles.erc721Tokens = tokens || []\n    } catch (error) {\n      logError(Errors._604, error.message)\n    }\n\n    return collectibles\n  }\n\n  static extractNFTAsset = (asset: TokenResult, nftTokens: NFTTokens): NFTAsset => {\n    const mainAssetAddress = asset.address\n    const numberOfTokens = nftTokens.filter(({ assetAddress }) => sameAddress(assetAddress, mainAssetAddress)).length\n\n    return {\n      address: mainAssetAddress,\n      description: asset.name,\n      image: asset.logoUri || NFTIcon,\n      name: asset.name,\n      numberOfTokens,\n      slug: `${mainAssetAddress}_${asset.name}`,\n      symbol: asset.symbol,\n    }\n  }\n\n  static extractAssets(assets: TokenResult[], nftTokens: NFTTokens): NFTAssets {\n    const extractedAssets = {}\n\n    assets.forEach((asset) => {\n      const address = asset.address\n\n      if (extractedAssets[address] === undefined) {\n        extractedAssets[address] = Gnosis.extractNFTAsset(asset, nftTokens)\n      }\n    })\n\n    return extractedAssets\n  }\n\n  static extractTokens(tokens: SafeCollectibleResponse[]): NFTTokens {\n    const items = tokens.map((token) => ({\n      assetAddress: token.address,\n      color: 'red',\n      description: token.description || '',\n      image: token.imageUri || NFTIcon,\n      name: token.name || '',\n      tokenId: token.id,\n    }))\n    return items\n  }\n\n  /**\n   * Fetches from OpenSea the list of collectibles, grouped by category,\n   * for the provided Safe Address in the specified Network\n   * @param {string} safeAddress\n   * @returns {Promise<Collectibles>}\n   */\n  async fetchCollectibles(safeAddress: string): Promise<Collectibles> {\n    const { erc721Assets, erc721Tokens } = await this._fetch(safeAddress)\n\n    const nftTokens = Gnosis.extractTokens(erc721Tokens)\n    const nftAssets = Gnosis.extractAssets(erc721Assets, nftTokens)\n\n    return { nftTokens, nftAssets }\n  }\n}\n\nexport default Gnosis\n","import Gnosis from 'src/logic/collectibles/sources/Gnosis'\nimport { COLLECTIBLES_SOURCE } from 'src/utils/constants'\n\nconst SOURCES = {\n  gnosis: new Gnosis(),\n}\n\ntype Sources = typeof SOURCES\n\nexport const getConfiguredSource = (): Sources['gnosis'] => SOURCES[COLLECTIBLES_SOURCE.toLowerCase()]\n","import { Dispatch } from 'redux'\n\nimport { getConfiguredSource } from 'src/logic/collectibles/sources'\nimport { addNftAssets, addNftTokens, setNftTokensLoaded } from 'src/logic/collectibles/store/actions/addCollectibles'\n\nexport const fetchCollectibles =\n  (safeAddress: string) =>\n  async (dispatch: Dispatch): Promise<void> => {\n    dispatch(setNftTokensLoaded(false))\n    try {\n      const source = getConfiguredSource()\n      const collectibles = await source.fetchCollectibles(safeAddress)\n\n      dispatch(addNftAssets(collectibles.nftAssets))\n      dispatch(addNftTokens(collectibles.nftTokens))\n      dispatch(setNftTokensLoaded(true))\n    } catch (error) {\n      dispatch(setNftTokensLoaded(false))\n      console.log('Error fetching collectibles:', error)\n    }\n  }\n","import { Dispatch } from 'src/logic/safe/store/actions/types.d'\n\nimport updateViewedSafes from 'src/logic/currentSession/store/actions/updateViewedSafes'\n\nconst addViewedSafe =\n  (safeAddress: string) =>\n  (dispatch: Dispatch): void => {\n    dispatch(updateViewedSafes(safeAddress))\n  }\n\nexport default addViewedSafe\n","import { Dispatch } from 'redux'\nimport { Action } from 'redux-actions'\n\nimport { updateSafe } from 'src/logic/safe/store/actions/updateSafe'\nimport { SafeRecordProps } from 'src/logic/safe/store/models/safe'\nimport { getLocalSafe } from 'src/logic/safe/utils'\nimport { getSafeInfo } from 'src/logic/safe/utils/safeInformation'\nimport { SafeInfo } from '@gnosis.pm/safe-react-gateway-sdk'\nimport { checksumAddress } from 'src/utils/checksumAddress'\nimport { buildSafeOwners, extractRemoteSafeInfo } from './utils'\nimport { AppReduxState, store } from 'src/store'\nimport { currentSafeWithNames } from '../selectors'\nimport fetchTransactions from './transactions/fetchTransactions'\nimport { fetchCollectibles } from 'src/logic/collectibles/store/actions/fetchCollectibles'\nimport { currentChainId } from 'src/logic/config/store/selectors'\nimport addViewedSafe from 'src/logic/currentSession/store/actions/addViewedSafe'\nimport { fetchSafeTokens } from 'src/logic/tokens/store/actions/fetchSafeTokens'\n\n/**\n * Builds a Safe Record that will be added to the app's store\n * It recovers, and merges information from client-gateway and localStore\n *\n * @note It's being used by \"Load Existing Safe\" and \"Create New Safe\" flows\n *\n * @param {string} safeAddress\n * @returns Promise<SafeRecordProps>\n */\nexport const buildSafe = async (safeAddress: string): Promise<SafeRecordProps> => {\n  const address = checksumAddress(safeAddress)\n  // setting `loadedViaUrl` to false, as `buildSafe` is called on safe Load or Open flows\n  const safeInfo: Partial<SafeRecordProps> = { address, loadedViaUrl: false }\n\n  const local = getLocalSafe(safeAddress)\n  const remote = await getSafeInfo(safeAddress).catch((err) => {\n    err.log()\n    return null\n  })\n\n  // remote (client-gateway)\n  const remoteSafeInfo = remote ? await extractRemoteSafeInfo(remote) : {}\n  // local\n  const localSafeInfo = local || ({} as Partial<SafeRecordProps>)\n\n  // update owner's information\n  const owners = buildSafeOwners(remote?.owners, localSafeInfo.owners)\n\n  return { ...localSafeInfo, ...safeInfo, ...remoteSafeInfo, owners } as SafeRecordProps\n}\n\n/**\n * Updates the app's store with Safe Record built from data provided by client-gateway\n *\n * @note It's being used by the app when it loads for the first time and for the Safe's data polling\n *\n * @param {string} safeAddress\n * @param {boolean} isInitialLoad\n */\nexport const fetchSafe =\n  (safeAddress: string, isInitialLoad = false) =>\n  async (dispatch: Dispatch<any>): Promise<Action<Partial<SafeRecordProps>> | void> => {\n    const dispatchPromises: ((dispatch: Dispatch, getState: () => AppReduxState) => Promise<void> | void)[] = []\n\n    const address = checksumAddress(safeAddress)\n\n    let safeInfo: Partial<SafeRecordProps> = {}\n    let remoteSafeInfo: SafeInfo | null = null\n\n    try {\n      remoteSafeInfo = await getSafeInfo(address)\n    } catch (err) {\n      err.log()\n    }\n\n    const state = store.getState()\n    const chainId = currentChainId(state)\n\n    // remote (client-gateway)\n    if (remoteSafeInfo) {\n      // If the network has changed while the safe was being loaded,\n      // ignore the result\n      if (remoteSafeInfo.chainId !== chainId) {\n        return\n      }\n\n      safeInfo = await extractRemoteSafeInfo(remoteSafeInfo)\n\n      // If these polling timestamps have changed, fetch again\n      const { collectiblesTag, txQueuedTag, txHistoryTag } = currentSafeWithNames(state)\n\n      const shouldUpdateCollectibles = collectiblesTag !== safeInfo.collectiblesTag\n      const shouldUpdateTxHistory = txHistoryTag !== safeInfo.txHistoryTag\n      const shouldUpdateTxQueued = txQueuedTag !== safeInfo.txQueuedTag\n\n      dispatchPromises.push(dispatch(fetchSafeTokens(address)))\n\n      if (shouldUpdateCollectibles || isInitialLoad) {\n        dispatch(fetchCollectibles(address))\n      }\n\n      if (shouldUpdateTxHistory || shouldUpdateTxQueued || isInitialLoad) {\n        dispatchPromises.push(dispatch(fetchTransactions(chainId, address)))\n      }\n\n      if (isInitialLoad) {\n        dispatchPromises.push(dispatch(addViewedSafe(address)))\n      }\n    }\n\n    const owners = buildSafeOwners(remoteSafeInfo?.owners || [])\n\n    await Promise.all(dispatchPromises)\n\n    return dispatch(updateSafe({ address, ...safeInfo, owners, loaded: true }))\n  }\n","import BigNumber from 'bignumber.js'\nimport { Dispatch } from 'redux'\n\nimport { fetchTokenCurrenciesBalances, TokenBalance } from 'src/logic/safe/api/fetchTokenCurrenciesBalances'\nimport { addTokens } from 'src/logic/tokens/store/actions/addTokens'\nimport { makeToken, Token } from 'src/logic/tokens/store/model/token'\nimport { updateSafe } from 'src/logic/safe/store/actions/updateSafe'\nimport { AppReduxState } from 'src/store'\nimport { humanReadableValue } from 'src/logic/tokens/utils/humanReadableValue'\nimport { currentSafe } from 'src/logic/safe/store/selectors'\nimport { currentCurrencySelector } from 'src/logic/currencyValues/store/selectors'\nimport { ZERO_ADDRESS, sameAddress } from 'src/logic/wallets/ethAddresses'\nimport { Errors, logError } from 'src/logic/exceptions/CodedException'\nimport { SafeBalanceResponse } from '@gnosis.pm/safe-react-gateway-sdk'\n\nexport type BalanceRecord = {\n  tokenAddress?: string\n  tokenBalance: string\n  fiatBalance?: string\n}\n\ninterface ExtractedData {\n  balances: Array<BalanceRecord>\n  ethBalance: string\n  tokens: Array<Token>\n}\n\nconst extractDataFromResult = (\n  acc: ExtractedData,\n  { balance, fiatBalance, tokenInfo }: TokenBalance,\n): ExtractedData => {\n  const { address, decimals } = tokenInfo\n\n  acc.balances.push({\n    tokenAddress: address,\n    fiatBalance,\n    tokenBalance: humanReadableValue(balance, Number(decimals)),\n  })\n\n  // Extract network token balance from backend balances\n  if (sameAddress(address, ZERO_ADDRESS)) {\n    acc.ethBalance = humanReadableValue(balance, Number(decimals))\n  } else {\n    acc.tokens.push(makeToken({ ...tokenInfo }))\n  }\n\n  return acc\n}\n\nexport const fetchSafeTokens =\n  (safeAddress: string, currency?: string) =>\n  async (dispatch: Dispatch, getState: () => AppReduxState): Promise<void> => {\n    const state = getState()\n    const safe = currentSafe(state)\n\n    if (!safe) {\n      return\n    }\n    const selectedCurrency = currency ?? currentCurrencySelector(state)\n\n    let tokenCurrenciesBalances: SafeBalanceResponse\n    try {\n      tokenCurrenciesBalances = await fetchTokenCurrenciesBalances({\n        safeAddress,\n        selectedCurrency,\n      })\n    } catch (e) {\n      logError(Errors._601, e.message)\n      return\n    }\n\n    const { balances, ethBalance, tokens } = tokenCurrenciesBalances.items.reduce<ExtractedData>(\n      extractDataFromResult,\n      {\n        balances: [],\n        ethBalance: '0',\n        tokens: [],\n      },\n    )\n\n    dispatch(\n      updateSafe({\n        address: safeAddress,\n        balances,\n        ethBalance,\n        totalFiatBalance: new BigNumber(tokenCurrenciesBalances.fiatTotal).toFixed(2),\n      }),\n    )\n    dispatch(addTokens(tokens))\n  }\n","import { getBalances, SafeBalanceResponse, TokenInfo } from '@gnosis.pm/safe-react-gateway-sdk'\nimport { _getChainId } from 'src/config'\nimport { checksumAddress } from 'src/utils/checksumAddress'\n\nexport type TokenBalance = {\n  tokenInfo: TokenInfo\n  balance: string\n  fiatBalance: string\n  fiatConversion: string\n}\n\ntype FetchTokenCurrenciesBalancesProps = {\n  safeAddress: string\n  selectedCurrency: string\n  excludeSpamTokens?: boolean\n  trustedTokens?: boolean\n}\n\nexport const fetchTokenCurrenciesBalances = async ({\n  safeAddress,\n  selectedCurrency,\n  excludeSpamTokens = true,\n  trustedTokens = false,\n}: FetchTokenCurrenciesBalancesProps): Promise<SafeBalanceResponse> => {\n  const address = checksumAddress(safeAddress)\n  return getBalances(_getChainId(), address, selectedCurrency, {\n    exclude_spam: excludeSpamTokens,\n    trusted: trustedTokens,\n  })\n}\n","import { ReactElement } from 'react'\nimport { Link } from 'react-router-dom'\nimport { Title } from '@gnosis.pm/safe-react-components'\nimport styled from 'styled-components'\nimport Button from 'src/components/layout/Button'\n\ninterface FetchErrorProps {\n  text: string\n  buttonText: string\n  redirectRoute: string\n  onClick?: () => void\n}\n\nconst StyledLink = styled(Link)`\n  text-decoration: none;\n`\n\nconst ErrorContainer = styled.div`\n  width: 100%;\n  height: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-direction: column;\n  // Offset so that it is centered relative to the header\n  margin-top: -30px;\n`\n\nconst FetchError = ({ text, buttonText, redirectRoute, onClick }: FetchErrorProps): ReactElement => {\n  return (\n    <ErrorContainer>\n      <img src=\"./resources/error.png\" alt=\"Error\" />\n\n      <Title size=\"xs\">{text}</Title>\n\n      <StyledLink to={redirectRoute} onClick={onClick}>\n        <Button color=\"primary\" size=\"medium\" variant=\"contained\">\n          {buttonText}\n        </Button>\n      </StyledLink>\n    </ErrorContainer>\n  )\n}\n\nexport default FetchError\n","import { ReactElement } from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\n\nimport { WELCOME_ROUTE } from 'src/routes/routes'\nimport removeViewedSafe from 'src/logic/currentSession/store/actions/removeViewedSafe'\nimport FetchError from './FetchError'\nimport { currentSafe } from 'src/logic/safe/store/selectors'\n\nconst SafeLoadError = (): ReactElement => {\n  const dispatch = useDispatch()\n\n  const { address } = useSelector(currentSafe)\n  const onClick = () => dispatch(removeViewedSafe(address))\n\n  return (\n    <FetchError\n      text=\"This Safe couldn't be loaded\"\n      buttonText=\"Back to Main Page\"\n      redirectRoute={WELCOME_ROUTE}\n      onClick={onClick}\n    />\n  )\n}\n\nexport default SafeLoadError\n","import { Dispatch } from 'redux'\nimport { getCurrentMasterContractLastVersion } from 'src/logic/safe/utils/safeVersion'\nimport setLatestMasterContractVersion from 'src/logic/safe/store/actions/setLatestMasterContractVersion'\n\nconst fetchLatestMasterContractVersion =\n  () =>\n  async (dispatch: Dispatch): Promise<void> => {\n    const latestVersion = await getCurrentMasterContractLastVersion()\n\n    dispatch(setLatestMasterContractVersion(latestVersion))\n  }\n\nexport default fetchLatestMasterContractVersion\n","import { GenericModal, Loader } from '@gnosis.pm/safe-react-components'\nimport { useState, lazy, useEffect } from 'react'\nimport { useSelector } from 'react-redux'\nimport { Redirect, Route, Switch } from 'react-router-dom'\n\nimport { currentSafeFeaturesEnabled, currentSafe } from 'src/logic/safe/store/selectors'\nimport { wrapInSuspense } from 'src/utils/wrapInSuspense'\nimport { LoadingContainer } from 'src/components/LoaderContainer'\nimport { generateSafeRoute, extractPrefixedSafeAddress, SAFE_ROUTES } from 'src/routes/routes'\nimport { FEATURES } from '@gnosis.pm/safe-react-gateway-sdk'\nimport { SAFE_POLLING_INTERVAL } from 'src/utils/constants'\nimport SafeLoadError from '../components/SafeLoadError'\nimport { useLoadSafe } from 'src/logic/safe/hooks/useLoadSafe'\nimport { useSafeScheduledUpdates } from 'src/logic/safe/hooks/useSafeScheduledUpdates'\nimport useSafeAddress from 'src/logic/currentSession/hooks/useSafeAddress'\n\nexport const BALANCES_TAB_BTN_TEST_ID = 'balances-tab-btn'\nexport const SETTINGS_TAB_BTN_TEST_ID = 'settings-tab-btn'\nexport const APPS_TAB_BTN_TEST_ID = 'apps-tab-btn'\nexport const TRANSACTIONS_TAB_BTN_TEST_ID = 'transactions-tab-btn'\nexport const ADDRESS_BOOK_TAB_BTN_TEST_ID = 'address-book-tab-btn'\nexport const SAFE_VIEW_NAME_HEADING_TEST_ID = 'safe-name-heading'\nexport const TRANSACTIONS_TAB_NEW_BTN_TEST_ID = 'transactions-tab-new-btn'\n\nconst Home = lazy(() => import('src/routes/Home'))\nconst Apps = lazy(() => import('src/routes/safe/components/Apps'))\nconst Settings = lazy(() => import('src/routes/safe/components/Settings'))\nconst Balances = lazy(() => import('src/routes/safe/components/Balances'))\nconst TxList = lazy(() => import('src/routes/safe/components/Transactions/TxList'))\nconst AddressBookTable = lazy(() => import('src/routes/safe/components/AddressBook'))\n\nconst Container = (): React.ReactElement => {\n  const featuresEnabled = useSelector(currentSafeFeaturesEnabled)\n  const { owners } = useSelector(currentSafe)\n  const { safeAddress } = useSafeAddress()\n  const isSafeLoaded = owners.length > 0\n  const [hasLoadFailed, setHasLoadFailed] = useState<boolean>(false)\n\n  useLoadSafe(safeAddress) // load initially\n  useSafeScheduledUpdates(safeAddress, hasLoadFailed) // load every X seconds\n\n  useEffect(() => {\n    if (isSafeLoaded) {\n      setHasLoadFailed(false)\n      return\n    }\n\n    const failedTimeout = setTimeout(() => {\n      setHasLoadFailed(true)\n    }, SAFE_POLLING_INTERVAL)\n    return () => {\n      clearTimeout(failedTimeout)\n    }\n  }, [isSafeLoaded])\n\n  const [modal, setModal] = useState({\n    isOpen: false,\n    title: null,\n    body: null,\n    footer: null,\n    onClose: () => {},\n  })\n\n  if (hasLoadFailed) {\n    return <SafeLoadError />\n  }\n\n  if (!isSafeLoaded) {\n    return (\n      <LoadingContainer>\n        <Loader size=\"md\" />\n      </LoadingContainer>\n    )\n  }\n\n  const closeGenericModal = () => {\n    if (modal.onClose) {\n      modal.onClose?.()\n    }\n\n    setModal({\n      isOpen: false,\n      title: null,\n      body: null,\n      footer: null,\n      onClose: () => {},\n    })\n  }\n\n  return (\n    <>\n      <Switch>\n        <Route exact path={SAFE_ROUTES.DASHBOARD} render={() => wrapInSuspense(<Home />)} />\n\n        {/* Legacy redirect */}\n        <Route\n          path={SAFE_ROUTES.LEGACY_COLLECTIBLES}\n          exact\n          render={() => (\n            <Redirect to={generateSafeRoute(SAFE_ROUTES.ASSETS_BALANCES_COLLECTIBLES, extractPrefixedSafeAddress())} />\n          )}\n        />\n\n        <Route\n          exact\n          path={[SAFE_ROUTES.ASSETS_BALANCES, SAFE_ROUTES.ASSETS_BALANCES_COLLECTIBLES]}\n          render={() => wrapInSuspense(<Balances />)}\n        />\n        <Route\n          exact\n          path={[\n            SAFE_ROUTES.TRANSACTIONS,\n            SAFE_ROUTES.TRANSACTIONS_HISTORY,\n            SAFE_ROUTES.TRANSACTIONS_QUEUE,\n            SAFE_ROUTES.TRANSACTIONS_SINGULAR,\n          ]}\n          render={() => wrapInSuspense(<TxList />)}\n        />\n        <Route exact path={SAFE_ROUTES.ADDRESS_BOOK} render={() => wrapInSuspense(<AddressBookTable />)} />\n        <Route\n          exact\n          path={SAFE_ROUTES.APPS}\n          render={({ history }) => {\n            if (!featuresEnabled.includes(FEATURES.SAFE_APPS)) {\n              history.push(generateSafeRoute(SAFE_ROUTES.ASSETS_BALANCES, extractPrefixedSafeAddress()))\n            }\n            return wrapInSuspense(<Apps />)\n          }}\n        />\n        <Route path={SAFE_ROUTES.SETTINGS} render={() => wrapInSuspense(<Settings />)} />\n        <Redirect to={SAFE_ROUTES.ASSETS_BALANCES} />\n      </Switch>\n      {modal.isOpen && <GenericModal {...modal} onClose={closeGenericModal} />}\n    </>\n  )\n}\nexport default Container\n","import { useEffect } from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\n\nimport fetchLatestMasterContractVersion from 'src/logic/safe/store/actions/fetchLatestMasterContractVersion'\nimport { fetchSafe } from 'src/logic/safe/store/actions/fetchSafe'\nimport { Dispatch } from 'src/logic/safe/store/actions/types.d'\nimport { updateAvailableCurrencies } from 'src/logic/currencyValues/store/actions/updateAvailableCurrencies'\nimport { currentChainId } from 'src/logic/config/store/selectors'\n\nexport const useLoadSafe = (safeAddress?: string): void => {\n  const dispatch = useDispatch<Dispatch>()\n  const chainId = useSelector(currentChainId)\n\n  useEffect(() => {\n    if (!safeAddress) return\n\n    const load = async () => {\n      dispatch(fetchLatestMasterContractVersion())\n      dispatch(fetchSafe(safeAddress, true))\n      dispatch(updateAvailableCurrencies())\n    }\n\n    load()\n  }, [dispatch, safeAddress, chainId])\n}\n","import { Action } from 'redux-actions'\nimport { ThunkDispatch } from 'redux-thunk'\nimport { AppReduxState } from 'src/store'\nimport { AvailableCurrenciesPayload } from 'src/logic/currencyValues/store/reducer/currencyValues'\nimport { setAvailableCurrencies } from 'src/logic/currencyValues/store/actions/setAvailableCurrencies'\nimport { getFiatCurrencies } from '@gnosis.pm/safe-react-gateway-sdk'\nimport { Errors, logError } from 'src/logic/exceptions/CodedException'\n\nexport const updateAvailableCurrencies =\n  () =>\n  async (dispatch: ThunkDispatch<AppReduxState, undefined, Action<AvailableCurrenciesPayload>>): Promise<void> => {\n    try {\n      const availableCurrencies = await getFiatCurrencies()\n      dispatch(setAvailableCurrencies({ availableCurrencies }))\n    } catch (err) {\n      logError(Errors._607, err.message)\n    }\n    return Promise.resolve()\n  }\n","import { useEffect, useState } from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\nimport { currentChainId } from 'src/logic/config/store/selectors'\nimport { fetchSafe } from 'src/logic/safe/store/actions/fetchSafe'\nimport { SAFE_POLLING_INTERVAL } from 'src/utils/constants'\n\nexport const useSafeScheduledUpdates = (safeAddress?: string, isInitialLoad = false): void => {\n  const dispatch = useDispatch()\n  const [pollCount, setPollCount] = useState<number>(0)\n  const chainId = useSelector(currentChainId)\n\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      if (safeAddress) {\n        dispatch(fetchSafe(safeAddress, isInitialLoad))\n      }\n      setPollCount((prev) => prev + 1)\n    }, SAFE_POLLING_INTERVAL)\n\n    return () => {\n      clearTimeout(timer)\n    }\n  }, [dispatch, safeAddress, chainId, pollCount, setPollCount, isInitialLoad])\n}\n"],"sourceRoot":""}